import re
from pathlib import Path
from typing import List, Set

from loguru import logger


class MalwareScanner:
    VENV_INDICATORS = {'venv', '.venv', 'env', '.env', 'site-packages', '__pycache__', 'node_modules'}
    
    SUSPICIOUS_EXTENSIONS = {'.exe', '.bat', '.cmd', '.com', '.scr', '.msi', '.vbs', '.js'}
    ALLOWED_BINARY_EXTENSIONS = {'.so', '.pyd', '.dll', '.dylib', '.whl'}
    
    SHELL_DANGEROUS_PATTERNS = [
        r'curl\s+.*\|\s*bash',
        r'curl\s+.*\|\s*sh',
        r'wget\s+.*\|\s*bash',
        r'wget\s+.*\|\s*sh',
        r'curl\s+.*>\s*/tmp/.*&&.*sh',
        r'wget\s+.*-O\s+.*&&.*sh',
    ]
    
    CRYPTO_MINER_PATTERNS = [
        r'stratum\+tcp://',
        r'xmrig',
        r'minerd',
        r'cpuminer',
        r'cgminer',
        r'bfgminer',
        r'nicehash',
        r'pool\.minergate',
        r'moneropool',
        r'cryptonight',
    ]
    
    NETWORK_EXFILTRATION_PATTERNS = [
        r'requests\.post\s*\(\s*["\']https?://[^"\']+["\'].*data\s*=',
        r'urllib\.request\.urlopen\s*\(\s*["\']https?://[^"\']+["\']',
        r'socket\.connect\s*\(\s*\(',
    ]
    
    APPROVED_BASE_IMAGES = [
        'python:3.11',
        'python:3.10',
        'python:3.9',
        'nvidia/cuda:12',
        'nvidia/cuda:11',
        'ubuntu:22.04',
        'ubuntu:20.04',
        'debian:bullseye',
        'debian:bookworm',
    ]

    def scan_repository(self, repo_path: Path) -> List[str]:
        issues = []
        
        issues.extend(self._scan_dockerfile(repo_path))
        issues.extend(self._scan_shell_scripts(repo_path))
        issues.extend(self._scan_for_miners(repo_path))
        issues.extend(self._scan_suspicious_binaries(repo_path))
        
        return issues

    def has_malware(self, repo_path: Path) -> str:
        issues = self.scan_repository(repo_path)
        
        if issues:
            return "; ".join(issues[:3])
        
        return ""

    def _scan_dockerfile(self, repo_path: Path) -> List[str]:
        issues = []
        dockerfile_path = repo_path / "Dockerfile"
        
        if not dockerfile_path.exists():
            return issues
        
        content = dockerfile_path.read_text(errors='ignore')
        
        for pattern in self.SHELL_DANGEROUS_PATTERNS:
            if re.search(pattern, content, re.IGNORECASE):
                issues.append(f"Dockerfile: Dangerous shell pattern detected: {pattern}")
        
        from_match = re.search(r'^FROM\s+([^\s]+)', content, re.MULTILINE)
        if from_match:
            base_image = from_match.group(1)
            if not self._is_approved_base_image(base_image):
                issues.append(f"Dockerfile: Unapproved base image: {base_image}")
        
        if re.search(r'--network\s*=\s*host', content):
            issues.append("Dockerfile: Host network mode is not allowed")
        
        if re.search(r'--privileged', content):
            issues.append("Dockerfile: Privileged mode is not allowed")
        
        return issues

    def _scan_shell_scripts(self, repo_path: Path) -> List[str]:
        issues = []
        
        for script_path in repo_path.rglob("*.sh"):
            if self._is_in_venv(script_path):
                continue
            
            content = script_path.read_text(errors='ignore')
            
            for pattern in self.SHELL_DANGEROUS_PATTERNS:
                if re.search(pattern, content, re.IGNORECASE):
                    issues.append(f"{script_path.name}: Dangerous shell pattern: {pattern}")
        
        for script_path in repo_path.rglob("*.bash"):
            if self._is_in_venv(script_path):
                continue
            
            content = script_path.read_text(errors='ignore')
            
            for pattern in self.SHELL_DANGEROUS_PATTERNS:
                if re.search(pattern, content, re.IGNORECASE):
                    issues.append(f"{script_path.name}: Dangerous shell pattern: {pattern}")
        
        return issues

    def _scan_for_miners(self, repo_path: Path) -> List[str]:
        issues = []
        
        for py_file in repo_path.rglob("*.py"):
            if self._is_in_venv(py_file):
                continue
            
            content = py_file.read_text(errors='ignore').lower()
            
            for pattern in self.CRYPTO_MINER_PATTERNS:
                if re.search(pattern, content, re.IGNORECASE):
                    issues.append(f"{py_file.name}: Crypto miner pattern detected")
                    break
        
        for config_file in repo_path.rglob("*.json"):
            if self._is_in_venv(config_file):
                continue
            
            content = config_file.read_text(errors='ignore').lower()
            
            for pattern in self.CRYPTO_MINER_PATTERNS:
                if re.search(pattern, content, re.IGNORECASE):
                    issues.append(f"{config_file.name}: Crypto miner config detected")
                    break
        
        return issues

    def _scan_suspicious_binaries(self, repo_path: Path) -> List[str]:
        issues = []
        
        for file_path in repo_path.rglob("*"):
            if not file_path.is_file():
                continue
            
            if self._is_in_venv(file_path):
                continue
            
            suffix = file_path.suffix.lower()
            
            if suffix in self.SUSPICIOUS_EXTENSIONS:
                issues.append(f"Suspicious binary: {file_path.name}")
        
        return issues

    def _is_approved_base_image(self, image: str) -> bool:
        for approved in self.APPROVED_BASE_IMAGES:
            if image.startswith(approved):
                return True
        return False

    def _is_in_venv(self, file_path: Path) -> bool:
        parts = file_path.parts
        return any(indicator in parts for indicator in self.VENV_INDICATORS)